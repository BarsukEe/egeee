#выражения с del (делимость) или с & (поразрядная коньюнкция)
def f(x):
    return выражение
for a in range(1,1000):
    if all(f(x)==1 for x in range(1,10000)):
        print(a)
#также, помимо x, может быть дан y, в таком случае в первую строку после x через запятую добавляем y, и в строку с условием дописываем for y in range(1,10000)

#1. Наименьшее мн-во:
#Элементами мн-ва A являются натуральные числа. Известно, что выражение (x {2,4,6,8,10,12} <= (((x {3,6,9,12,15}) and (not(x A))) <= (not x {2,4,6,8,10,12}))) истинно, т.е принимает значение 1 при любом значении переменной x. Определить наименьшее возможное значение суммы элементов мн-ва А.
a=set()
p={промежуток 1}
q={промежуток 2}
def f(x):
    A = x in a
    P = x in p
    Q = x in q
    return выражение
for x in range(1,100):
    if f(x) == 0:
        a.add(x)
print(a)

#Наибольшее множество
#Задача схожа, только тут в условии сразу даются списки и выражение записывается уже с буквами.
a=set(range(1,100))
p={}
q={}

def f(x):
    A = x in a
    P = x in p
    Q = x in q
    return выражение
for x in range(1,100):
    if f(x) == 0:
        a.remove(x)
print(a)

#Отрезки. Нам даются отрезки p=[43;49], q=[44,53] и выражение. Найти нужно наибольшую возможную длину отрезка а
from itertools import *

def f(x):
    p = 43 <= x <= 49
    q = 44 <= x <= 53
    a = a1 <= x <= a2
    return выражение
ox=[i/4 for i in range(42*4,54*4)] #Берём значения на 1 больше и меньше исходных: максимальное было 53, мы берём 54. Минимальное было 43 - мы берём 42. Также стандартно умножаем на 4.
m=[]
for a1, a2 in combinations(ox,2):
    if all(f(x) == 1 for x in ox):
        m.append(a2-a1)
print(max(m))




#15 егэ битовые цепочки
from itertools import *
bit=[''.join(i) for i in product('01',repeat=8)]
a=set()
p={i for i in bit if i[0]+i[1]=='11'}
q={i for i in bit if i[-1]=='0'}
def f(x):
    A=x in a
    P=x in p
    Q=x in q
    return (not A)<=((not P) or Q)
for x in bit:
    if f(x)==0:
        a.add(x)
print(len(a))


#Выражения или арифметические операции.
# Целые положительные начинаются с 1
# Целые неотрицательные начинаются с 0
def f(x,y):
    return выражение
for a in range(1,100):
    if all(f(x,y) == 1 for x in range(1,1000) for y in range(1,1000)):
        print(a)



#задача с егкр 13.12.2025
p=[]
def f(x,y):
 return (78125!=y+4*x) or (A>x) and (A>y)
#импликация (not(78125==y+4*x)) or (A>x) and (A>y)
#(78125=y+4*x)<=((A>x) and (A>y)
for y in range(1,100000):
    for x in range(1,100000):
 if y==78125-4*x:
 p.append([x,y])
for A in range(0,1000):
 if all(f(x,y)==1 for x,y in p):
 print(A)



#На числовой прямой дан отрезок A=[3;60]; B - мн-во всех натуральных чиел делителей числа 177, отличных от единицы и от самого числа 177; С - мн-во всех натуральных делителей некоторого натурального числа y, отличных от единицы и от самого числа y (число y таково, что мн-во C непустое). Укажите наибольшее значение числа y, для которого выражение (x принадлежит C) <= ((x принадлежит A) and (not (ч принадлежит B))) истинно (т.е принимает значение 1) при любом значении переменной x.
mx=[]
def f(x):
    return (x in C)<=((x in A) and (x not in B))
A=[x for x in range(3,61)]
B=[x for x in range(2,177) if 177%x==0]
for y in range(1,10000):
    C=[x for x in range(2,y) if y%x==0]
    if len(C)>0:
        if all(f(x) for x in range(1,100000))==1:
            mx.append(y)

print(max(mx))
