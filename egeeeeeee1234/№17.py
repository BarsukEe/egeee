#одно из лёгких заданий, но всю ситуацию усложняет массивность кода, аспект знаний и данные условия, которые после прочтения задания могут быть абсолютно непонятны.
#Начало всегда стандартное:
f=open('название файла.txt')
a=[int(x) for x in f]
k=0
c=0
maks=-100000
itog=-10000001
#также можно ввести минимальные числа, основанные на отрезке чисел в файле. в основном они помогают, когда нужно найти наименьшее число, наибольшее, наименьшую из сумм или наименьшее произведение и тд и тп.
for i in range(len(a)):
    #здесь мы перебираем абсолютно все числа. как правило, в задании нас просят вывести либо максимальное четырёхзначное, либо ещё какое число из последовательности - тобеж из всего файла. к примеру нам нужно максимальное трёхзначное число. Заранее вводим переменную maks, чтобы найти хотя бы одно число, подходящее под условие.
    if 99<abs(a[i])<1000 and a[i]>maks:
        maks=a[i]
        # здесь a[i] - число из последовательности. Поскольку нам нужно найти трёхзначное число - воспользуемся модулем, чтобы отдельно не писать проверку для отрицательных трёхзначных чисел, после мы сравниваем наше трёхзначное число сначала с самым минимальным. оно (трёхзначное число), очевидно, окажется больше и переменная maks возьмёт уже значение нашего трёхзначного числа. После новые трёхзначные числа будут сравниваться с предыдущими трёхзначными числами. по итогу в нашей переменной maks будет как раз наибольшее трёхзначное число.

for i in range(len(a)-2):
    #а вот тут мы уже рассматриваем "компании" чисел. Если нам нужно работать с двойками - вписываем range(len(a)-1), если с тройками, как например здесь - range(len(a)-2). Обращаться к нашим числам мы тоже будем по другому: a[i] - первый элемент тройки, a[i+1] - второй элемент тройки, a[i+2] - третий. Представим, что нам нужно найти количество троек, в которых два числа из трёх - четырёхзначные, и их произведение больше нашего максимального трёхзначного элемента последовательности (переменная maks).
    if (((999<abs(a[i])<10000) + (999<abs(a[i+1])<10000) + (999<abs(a[i+2])<10000))==2) and (a[i]*a[i+1]*a[i+2])>maks:
        #чтобы не писать километровое условия с or и and, можем вспомнить один интересные момент: если условие правдиво (True) - оно равно одному. Так и здесь: если ровно два из трёх элементов четырёхзначны - мы работаем со вторым условием. Также настоятельно рекомендую абсолютно каждое условие, каждое вычисление и тд брать в скобки, ибо приоритетность действий может пойти наперекосяк, и ответ будет уж слишком далёк от реальности. А теперь найдём последнее число для ответа: наибольшее из произведений подходящих нам троек.
        k+=1
        proizv=(a[i]+a[i+1]*a[i+2])
        if proizv>itog:
            itog=proizv
            #в начале я добовляю переменную itog=-10000001, поскольку может произойти ситуация, что все произведения будут отрицательными - я ставлю минус перед всем числом. Далее мы сравниваем произведение всех подошедших под основное условие троек (переменная proizv, стр 21) с нашей переменной itog. 
print(k,itog)

#И, наконец, вывод: k - кол-во подошедших троек, и itog - наибольшее из произведений. Безусловно, изначальное значение переменной itog (стр 8) довольно большое, согласен, но я предпочитаю перестраховаться.

